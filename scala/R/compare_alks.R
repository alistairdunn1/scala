#' Compare Age-Length Keys from Modelled and Empirical Methods
#'
#' Compares an age-length key generated by the ordinal GAM model
#' (\code{fit_ordinal_alk}) with an empirical key created by \code{create_alk}.
#' Produces per-cell differences and summary metrics by length and sex, with an
#' optional visualisation of differences.
#'
#' @param ordinal An \code{ordinal_alk} object returned by \code{fit_ordinal_alk()}.
#' @param empirical_alk A complete ALK from \code{create_alk()} (data.frame or
#'   named list of sex-specific data.frames) with columns: length, age, proportion, n (optional).
#' @param lengths Optional numeric vector of lengths to compare. Defaults to the
#'   unique lengths present in \code{empirical_alk}.
#' @param sexes Optional character vector of sex categories to compare when applicable
#'   (subset of ordinal$sex_levels and those present in empirical_alk). If NULL, use
#'   their intersection.
#' @param plot Logical, whether to return a ggplot heatmap of differences (default FALSE).
#'
#' @return A list with components:
#'   \itemize{
#'     \item \code{differences}: data.frame of per-cell differences with columns (length, age, sex, prop_empirical, prop_model, diff, abs_diff)
#'     \item \code{by_length}: summary metrics by length (and sex if applicable): RMSE, MAE, MaxAbs
#'     \item \code{overall}: overall summary metrics across compared cells
#'     \item \code{plot}: ggplot object when \code{plot=TRUE}, otherwise NULL
#'   }
#' @export
compare_alks <- function(ordinal, empirical_alk, lengths = NULL, sexes = NULL, plot = FALSE) {
  # Basic checks
  if (is.null(ordinal) || !inherits(ordinal, "ordinal_alk")) {
    stop("'ordinal' must be an object returned by fit_ordinal_alk()")
  }
  if (!(is.list(empirical_alk) || is.data.frame(empirical_alk))) {
    stop("'empirical_alk' must be a data.frame or a named list of data.frames from create_alk()")
  }

  # Helper: standardise empirical ALK into a single data.frame: length, age, sex (opt), proportion, n (opt)
  to_empirical_df <- function(x) {
    if (is.list(x) && !is.data.frame(x)) {
      # Bind sex-specific frames; ensure each has required cols
      parts <- lapply(names(x), function(sx) {
        df <- x[[sx]]
        if (!all(c("length", "age", "proportion") %in% names(df))) {
          stop("empirical_alk list elements must have columns length, age, proportion")
        }
        df$sex <- sx
        df
      })
      out <- do.call(rbind, parts)
      rownames(out) <- NULL
      out
    } else {
      if (!all(c("length", "age", "proportion") %in% names(x))) {
        stop("empirical_alk must contain columns length, age, proportion")
      }
      # If sex missing, add
      if (!("sex" %in% names(x))) x$sex <- "unsexed"
      x
    }
  }

  emp <- to_empirical_df(empirical_alk)

  # Coerce types
  emp$length <- as.numeric(emp$length)
  emp$age <- suppressWarnings(as.numeric(as.character(emp$age)))
  if (!is.finite(sum(emp$age))) {
    # fallback: treat as integer labels if still not numeric
    emp$age <- as.numeric(factor(emp$age))
  }

  # Determine lengths to compare
  if (is.null(lengths)) lengths <- sort(unique(emp$length))
  lengths <- sort(unique(as.numeric(lengths)))

  # Determine sexes present
  model_by_sex <- isTRUE(ordinal$by_sex)
  if (model_by_sex) {
    model_sexes <- ordinal$sex_levels
    emp_sexes <- sort(unique(as.character(emp$sex)))
    if (is.null(sexes)) {
      sexes <- intersect(emp_sexes, model_sexes)
      if (length(sexes) == 0) stop("No overlapping sex categories between model and empirical ALK")
    } else {
      sexes <- intersect(sexes, intersect(emp_sexes, model_sexes))
      if (length(sexes) == 0) stop("Provided 'sexes' not present in both model and empirical ALK")
    }
  } else {
    sexes <- "unsexed"
  }

  # Ages from model (ensure numeric if possible)
  age_levels <- ordinal$age_levels
  ages_num <- suppressWarnings(as.numeric(as.character(age_levels)))
  if (all(is.finite(ages_num))) {
    model_ages <- ages_num
  } else {
    model_ages <- seq_along(age_levels)
  }

  # Build model-predicted ALK over requested lengths and sexes
  build_model_df <- function(sex_label) {
    probs <- ordinal$predict_function(lengths, sex = if (model_by_sex) sex_label else NULL)
    # probs: n_len x K with colnames like age_1, age_2, ...
    col_ages <- gsub("^age_", "", colnames(probs))
    col_ages_num <- suppressWarnings(as.numeric(col_ages))
    if (!all(is.finite(col_ages_num))) {
      col_ages_num <- seq_len(ncol(probs))
    }
    # Convert to long form
    out <- data.frame(
      length = rep(lengths, times = ncol(probs)),
      age = rep(col_ages_num, each = length(lengths)),
      proportion = as.numeric(probs),
      sex = sex_label,
      stringsAsFactors = FALSE
    )
    out
  }

  model_df_list <- lapply(sexes, build_model_df)
  model_df <- do.call(rbind, model_df_list)
  rownames(model_df) <- NULL

  # Filter empirical to the same grid (lengths × model ages × selected sexes)
  emp_sub <- emp[emp$length %in% lengths & emp$sex %in% sexes & emp$age %in% model_ages, c("length", "age", "sex", "proportion")]

  # Merge and compute differences; fill missing proportions with 0
  key <- paste(emp_sub$length, emp_sub$age, emp_sub$sex, sep = "|")
  all_keys <- unique(c(key, paste(model_df$length, model_df$age, model_df$sex, sep = "|")))
  parse_key <- function(k) {
    sp <- strsplit(k, "\\|")[[1]]
    data.frame(length = as.numeric(sp[1]), age = as.numeric(sp[2]), sex = sp[3], stringsAsFactors = FALSE)
  }
  grid_df <- do.call(rbind, lapply(all_keys, parse_key))

  emp_map <- paste(emp_sub$length, emp_sub$age, emp_sub$sex, sep = "|")
  mod_map <- paste(model_df$length, model_df$age, model_df$sex, sep = "|")

  grid_df$prop_empirical <- 0
  grid_df$prop_model <- 0
  # Map in empirical
  if (nrow(emp_sub) > 0) {
    m1 <- match(all_keys, emp_map)
    grid_df$prop_empirical[!is.na(m1)] <- emp_sub$proportion[m1[!is.na(m1)]]
  }
  # Map in model
  if (nrow(model_df) > 0) {
    m2 <- match(all_keys, mod_map)
    grid_df$prop_model[!is.na(m2)] <- model_df$proportion[m2[!is.na(m2)]]
  }

  # Differences and summaries
  grid_df$diff <- grid_df$prop_model - grid_df$prop_empirical
  grid_df$abs_diff <- abs(grid_df$diff)
  grid_df$sq_diff <- grid_df$diff^2

  # Summaries by length and sex
  agg_by <- function(df, by_cols) {
    # Aggregate safe in base R
    rmse <- aggregate(df$sq_diff, by = by_cols, FUN = function(x) sqrt(mean(x)))
    mae <- aggregate(df$abs_diff, by = by_cols, FUN = mean)
    mx <- aggregate(df$abs_diff, by = by_cols, FUN = max)
    out <- rmse
    names(out)[ncol(out)] <- "RMSE"
    out$MAE <- mae[[ncol(mae)]]
    out$MaxAbs <- mx[[ncol(mx)]]
    out
  }

  by_cols <- list(length = grid_df$length)
  if (length(sexes) > 1) by_cols$sex <- grid_df$sex
  by_length <- agg_by(grid_df, by_cols)

  # Overall summary
  overall <- list(
    RMSE = sqrt(mean(grid_df$sq_diff)),
    MAE = mean(grid_df$abs_diff),
    MaxAbs = max(grid_df$abs_diff)
  )

  # Optional plot
  plt <- NULL
  if (isTRUE(plot)) {
    if (!requireNamespace("ggplot2", quietly = TRUE)) {
      warning("ggplot2 not installed; returning summaries without plot")
    } else {
      dfp <- grid_df
      # Keep sign for diverging palette
      plt <- ggplot2::ggplot(dfp, ggplot2::aes(x = age, y = length, fill = diff)) +
        ggplot2::geom_tile() +
        ggplot2::scale_fill_viridis_c(option = "C", name = "Model - Empirical", direction = -1) +
        ggplot2::labs(x = "Age", y = "Length", title = "ALK difference (model - empirical)") +
        ggplot2::theme_minimal()
      if (length(sexes) > 1) plt <- plt + ggplot2::facet_wrap(~sex)
    }
  }

  list(
    differences = grid_df[order(grid_df$sex, grid_df$length, grid_df$age), c("length", "age", "sex", "prop_empirical", "prop_model", "diff", "abs_diff")],
    by_length = by_length[order(by_length$length, if ("sex" %in% names(by_length)) by_length$sex else by_length$length), ],
    overall = overall,
    plot = plt
  )
}
